"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=new class{elements;observer;rafID=null;queue=[];resizePrecisionPower=1;constructor(){this.elements=null,this.observer=null}onElementResize(t){this.queue.push(...t),this.rafID||(this.rafID=requestAnimationFrame((()=>this.flushQueue())))}flushQueue(){const t=new Map;for(const e of this.queue)t.set(e.target,e);this.queue=[],t.forEach(((t,e)=>{if(!e.isConnected)return void this.unobserve(e);const r=this.elements?.get(e);if(!r)return;let{width:s,height:i}=t.contentRect;r.cornerOptions.isRounded&&(s=Math.round(s),i=Math.round(i));const{previousW:o,previousH:n,draw:h,onResize:a}=r;o===s&&n===i||(h?.({width:s,height:i}),a?.({width:s,height:i},t.target),r.previousW=s,r.previousH=i)})),this.rafID=null}getDrawOptions=t=>this.elements?.get(t)?.cornerOptions??null;setCornerOptions(t,e){const r=this.elements?.get(t);r&&(r.cornerOptions=e,this.elements?.set(t,r))}addElement(t,e,r){this.elements||(this.elements=new Map),this.observer||(this.observer=new ResizeObserver((t=>this.onElementResize(t)))),this.unobserve(t);const{observe:s=!0,onResize:i}=e;if(s){const s=null,o=null;this.elements.set(t,{draw:r,cornerOptions:e,onResize:i,previousW:s,previousH:o,element:t}),this.observer.observe(t)}return r}draw(t,e){const run=t=>{if(!t.element.isConnected)return;let{previousW:e,previousH:r}=t;null!==e&&null!==r||(e=t.element.offsetWidth,r=t.element.offsetHeight,t.previousW=e,t.previousH=r),t.draw?.({width:e,height:r})};if(t){e&&this.setCornerOptions(t,e);const r=this.elements?.get(t);r&&run(r)}else this.elements?.forEach(run)}unobserve(t){const funk=t=>{this.observer?.unobserve(t),this.elements?.delete(t)};t?funk(t):this.elements?.keys().forEach((t=>funk(t)))}};function createSquircleCorner(t,e,r,s,i,o,n,h){if(r){const h=[];return t&&h.push(["c",...s]),i&&h.push(["a",r,r,0,0,e,...o.map((t=>t*i))]),t&&h.push(["c",...n]),h}return[["l",...h]]}const createPath$6=({width:t,height:e,radii:r,offsets:s,smoothing:i=1,preserveSmoothing:o=!0,sweepFlag:n=1})=>{const[h,,,a]=s,[c,l,u,f]=r.map((r=>function(t,e,r,s){let i=(1+e)*t;r||(e=Math.min(e,s/t-1),i=Math.min(i,s));const o=.5*Math.PI*(1-e),n=Math.sin(o/2)*t*2**.5,h=.25*Math.PI*e,a=t*Math.tan(.25*(.5*Math.PI-o))*Math.cos(h),c=a*Math.tan(h);let l=(i-n-a-c)/3,u=2*l;if(r&&i>s){const t=s-c-n-a,e=t-t/6;l=Math.min(l,e),u=t-l,i=Math.min(i,s)}return{a:u,b:l,c:a,d:c,p:i,arcLength:n,radius:t,ab:u+l,bc:l+a,abc:u+l+a}}(r,i,o,Math.max(r,.5*Math.min(t,e)))));return[["M",t-l.p+a,h],...createSquircleCorner(i,n,l.radius,[l.a,0,l.ab,0,l.abc,l.d],l.arcLength,[1,1],[l.d,l.c,l.d,l.bc,l.d,l.abc],[l.p,0]),["L",t+a,e-u.p+h],...createSquircleCorner(i,n,u.radius,[0,u.a,0,u.ab,-u.d,u.abc],u.arcLength,[-1,1],[-u.c,u.d,-u.bc,u.d,-u.abc,u.d],[0,u.p]),["L",f.p+a,e+h],...createSquircleCorner(i,n,f.radius,[-f.a,0,-f.ab,0,-f.abc,-f.d],f.arcLength,[-1,-1],[-f.d,-f.c,-f.d,-f.bc,-f.d,-f.abc],[-f.p,0]),["L",a,c.p+h],...createSquircleCorner(i,n,c.radius,[0,-c.a,0,-c.ab,c.d,-c.abc],c.arcLength,[1,-1],[c.c,-c.d,c.bc,-c.d,c.abc,-c.d],[0,-c.p]),["Z"]]},fix=t=>{const e=10**t;return t=>Math.round(t*e)/e};function createGradient({id:t,angle:e,colors:r,precision:s}){const i=fix(s),o=e*(Math.PI/180),n=Math.sin(o),h=-Math.cos(o),a=(n>=0?1:0)-.5,c=(h>=0?1:0)-.5,l=Math.abs(a*n+c*h);return`<linearGradient id="${t}" x1="${i(.5-l*n)}" y1="${i(.5-l*h)}"  x2="${i(.5+l*n)}" y2="${i(.5+l*h)}" gradientUnits="objectBoundingBox">${function(t,e){const r=fix(e),s=t.map((t=>{const e=t.trim().split(/\s+/),r=e[0];let s=null;if(e.length>1){const t=e[1];s=t.includes("%")?parseFloat(t)/100:parseFloat(t)}return{color:r,val:s}})),i=s.length;null===s[0].val&&(s[0].val=0),null===s[i-1].val&&(s[i-1].val=1);let o=0;for(;o<i-1;){let t=o+1;for(;t<i&&null===s[t].val;)t++;if(t>o+1){const e=s[o].val,r=t-o,i=(s[t].val-e)/r;for(let t=1;t<r;t++)s[o+t].val=e+i*t}o=t}return s.map((t=>`<stop offset="${r(t.val)}" stop-color="${t.color}" />`)).join("")}(r,s)}</linearGradient>`}const e=/[\r\n"%#()<>?[\\\]^`{|}\s']/g,r={"\r":"","\n":""};function createPath({width:t=0,height:e=0,borderRadius:r=0,offset:s=0,smoothing:i=1,cornerType:o=createPath$6,precision:n=3,isArray:h=!1}){if(!t||!e)return h?[]:"";const a=Array.isArray(s)?s:[s,s,s,s],[c,l,u,f]=a,p=t-f-l,d=e-c-u;let g,M;if(Array.isArray(r)){const t=r.map(((t,e)=>t+r[(e+1)%4])),e=Math.min(...t.map(((t,e)=>(e%2==0?p:d)/t)));g=e<1?r.map((t=>t*e)):r}else g=[r,r,r,r].map(((t,e)=>Math.max(0,Math.min(t-a[e],.5*Math.min(p,d)))));M=o?o({width:p,height:d,radii:g,offsets:a,smoothing:i}):[[]];const w=fix(n);if(h)return M.filter((t=>t[0])).map((([t,...e])=>[t,...e.map((t=>"number"==typeof t?w(t):t))]));let $="";for(let t=0;t<M.length;t++){const e=M[t];if(e[0]){$+=e[0];for(let t=1;t<e.length;t++){const r=e[t];$+=("number"==typeof r?w(r):r)+" "}}}return $.trim()}exports.FigmaSquircle=t=>createPath$6({...t,preserveSmoothing:!1,sweepFlag:1}),exports.Flat=({width:t,height:e,radii:r,offsets:s})=>{const[i,,,o]=s,[n,h,a,c]=r;return[["M",o+n,i],["L",t-h+o,i],["L",t+o,i+h],["L",t+o,e-a+i],["L",t-a+o,e+i],["L",o+c,e+i],["L",o,e-c+i],["L",o,i+n],["Z"]]},exports.Inset=({width:t,height:e,radii:r,offsets:s})=>{const[i,,,o]=s,[n,h,a,c]=r;return[["M",o+c,i],["L",t-h+o,i],["L",t-h+o,i+h],["L",t+o,i+h],["L",t+o,e-a+i],["L",t-a+o,e-a+i],["L",t-a+o,e+i],["L",o+c,e+i],["L",o+c,e-c+i],["L",o,e-c+i],["L",o,i+n],["L",o+n,i+n],["L",o+n,i],["Z"]]},exports.Round=t=>createPath$6({...t,smoothing:0,preserveSmoothing:!1,sweepFlag:1}),exports.RoundInverse=t=>createPath$6({...t,smoothing:0,preserveSmoothing:!1,sweepFlag:0}),exports.Squircle=createPath$6,exports.addCorners=function(s,i){t.setCornerOptions(s,i);const drawFunk=i=>{const o=t.getDrawOptions(s)??{},n={...o,...i};n.isRounded&&(n.width=n.width?Math.round(n.width):void 0,n.height=n.height?Math.round(n.height):void 0),n.width&&n.height&&(s.style.clipPath=o.clip?`path('${createPath(n)}')`:"",(o.background||o.border)&&(s.style.backgroundImage=function(t){const{border:s=[],offset:i=0,strokeDrawType:o=0,background:n,clip:h,idPrefix:a="m",width:c,height:l,precision:u=3}=t,f=[],p=Array.isArray(s?.[0])?s:[s],d=Array.isArray(i)?i:[i,i,i,i],g=h?null:createPath(t);let M;if(p?.length){let e=0;const r=[];for(let s=0;s<p.length;s++)if("number"==typeof p[s][1]){const[n,h,c]=p[s];if(n){const l=`${a}g${s}`;M||(M=[]),M.push(createGradient({id:l,angle:h,colors:c,precision:u}));const f=0===o?2*(e+n):n;r.push(`<path d="${createPath({...t,offset:0===o?i:d.map((t=>t+e+.5*n))})}" fill="none" stroke="url(#${l})" stroke-width="${f}" />`),e+=n}}else{const[n,h]=p[s];if(n){const s=0===o?2*(e+n):n;r.push(`<path d="${createPath({...t,offset:0===o?i:d.map((t=>t+e+.5*n))})}" fill="none" stroke="${h}" stroke-width="${s}" />`),e+=n}}n&&(h?f.push(`<rect width="${c}" height="${l}" fill="${n}" />`):f.push(`<path d="${g}" fill="${n}" />`)),f.push(...r.reverse())}return f.length?(({paths:t,gradients:s,clipPath:i,idPrefix:o})=>{const n=`${o}c`,h=[],a=[];return s&&s.forEach((t=>{h.push(t)})),i&&h.push(`<clipPath id="${n}"><path d="${i}" /></clipPath>`),h.length&&a.push(`<defs>${h.join("")}</defs>`),i?a.push(`<g clip-path="url(#${n})">${t.join("")}</g>`):a.push(...t),`url('data:image/svg+xml,${(t=>t.replace(e,(t=>r[t]??(r[t]=`%${t.charCodeAt(0).toString(16).toUpperCase()}`))))((c=a.join(""),`<svg xmlns="http://www.w3.org/2000/svg">${c}</svg>`))}')`;var c})({paths:f,clipPath:g,gradients:M,idPrefix:a}):"none"}(n)))};return drawFunk(),t.addElement(s,i,drawFunk)},exports.createPath=createPath,exports.draw=function(e,r){t.draw(e,r)},exports.unobserve=function(e){t.unobserve(e)};
